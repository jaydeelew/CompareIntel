name: Deploy to Production

on:
  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: 'Skip test verification (emergency deploys only)'
        required: false
        default: false
        type: boolean

  # Auto-deploy on master branch (after CI passes)
  push:
    branches: [master]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'

# Only one deployment at a time
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  # ============================================================================
  # Verify CI Status Before Deploy
  # ============================================================================
  verify-ci:
    name: Verify CI Status
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    
    steps:
      - name: Check CI workflow status
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch: context.ref.replace('refs/heads/', ''),
              per_page: 1,
            });
            
            if (runs.workflow_runs.length === 0) {
              core.setFailed('No CI runs found for this branch');
              return;
            }
            
            const latestRun = runs.workflow_runs[0];
            if (latestRun.conclusion !== 'success') {
              core.setFailed(`CI workflow did not pass. Status: ${latestRun.conclusion}`);
              return;
            }
            
            console.log('âœ… CI workflow passed');

  # ============================================================================
  # Build Docker Images
  # ============================================================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: verify-ci
    if: always() && (needs.verify-ci.result == 'success' || needs.verify-ci.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: build
          push: false
          tags: compareintel-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Build backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: false
          tags: compareintel-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # Deploy to Server
  # ============================================================================
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd ~/CompareIntel
            
            # Pull latest code
            git fetch origin
            git reset --hard origin/${{ github.ref_name }}
            
            # Run deployment script
            ./deploy-production.sh quick-deploy
            
            echo "Deployment completed at $(date)"
      
      - name: Verify deployment
        env:
          DEPLOY_URL: ${{ secrets.DEPLOY_URL }}
        run: |
          # Wait for services to start
          sleep 30
          
          # Check if site is accessible
          curl -f -s -o /dev/null -w "%{http_code}" "${DEPLOY_URL}" || exit 1
          echo "âœ… Site is accessible"
      
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered by | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Time | $(date -u +'%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
      
      - name: Notify on failure
        if: failure()
        run: echo "âŒ Deployment failed!"

  # ============================================================================
  # Post-Deployment Health Checks
  # ============================================================================
  health-check:
    name: Post-Deployment Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy
    
    env:
      DEPLOY_URL: ${{ secrets.DEPLOY_URL }}
    
    steps:
      - name: Check API health
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" "${DEPLOY_URL}/api/health")
          if [ "$response" != "200" ]; then
            echo "âŒ API health check failed with status: $response"
            exit 1
          fi
          echo "âœ… API is healthy"
      
      - name: Check frontend
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" "${DEPLOY_URL}/")
          if [ "$response" != "200" ]; then
            echo "âŒ Frontend check failed with status: $response"
            exit 1
          fi
          echo "âœ… Frontend is accessible"
      
      - name: Check SSL certificate
        run: |
          DOMAIN=$(echo "${DEPLOY_URL}" | sed 's|https://||' | sed 's|/.*||')
          echo | openssl s_client -servername "${DOMAIN}" -connect "${DOMAIN}:443" 2>/dev/null | openssl x509 -noout -dates
          echo "âœ… SSL certificate is valid"
      
      - name: Create health check summary
        run: |
          echo "## âœ… Health Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All post-deployment health checks passed:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… API health endpoint responding" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Frontend accessible" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… SSL certificate valid" >> $GITHUB_STEP_SUMMARY